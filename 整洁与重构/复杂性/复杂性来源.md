# 复杂性的来源

软件本身如此易变(malleable),因此软件设计是持续的过程，贯穿软件系统的整个生命周期。软件设计的这个特点，使它和现实世界中实体系统(例如建筑，船舶，桥梁)的设计差异很大。然而，人们并不是从一开始就认可软件设计设计的持续性特点。在软件开发历史上很大一部分时间里，设计被认为和其他的工程一样：设计过程集中在项目的开始阶段.这种方式的一个极端就是瀑布式开发模型。在这个模型中，项目被划分为分离(discrete)的各个阶段:需求分析，设计，编码，测试和维护，前一个阶段在下一个阶段开始前结束，并且很多场景下，不同人负责不同的阶段。整个系统的设计工作在设计阶段一次性完成，这个阶段结束后，设计就冻结了。后面的各个阶段就是逐步实现设计的过程.

不幸的是，瀑布流开发模型很少在软件开发中有效。软件系统比其他实体系统内在(intrinsically)复杂性更高.大型软件系统，很难在开发前设想清楚系统设计个各个方面和准确理解各个设计决策的影响。结果是，初始的设计会有很多问题，这些问题一开始并不明显，在实现的过程中才变得更加清晰。瀑布开发模型没有组织上的保障来适应这种设计变化(例如:软件设计人员可能已经调整到其他项目上). 因此，开发人员尝试在不修改整体设计的前提下，通过补丁(patch)的方式来修复问题.这导致复杂性的爆炸性增长.

因为有这些问题，今天大部分软件开发项目采用了增量式开发模式(例如敏捷开发模式).在这种模式下，初始的设计聚焦在整体功能的一小部分上进行设计，实现和评估。初始设计的问题逐步被发现，并被纠正。随后更多的功能点被设计，实现和评估。每个迭代都暴露已有设计的问题，这些问题在下一个功能集的设计前得到解决。通过将设计的分散(spread out)，初始设计的问题能够在系统还很小的阶段得到修复。得益于初始阶段获得的经验，后续功能设计问题会更少.

这种增量式开发模型之所以有效，是因为软件系统具有足够的可塑性(malleable)，使得在软件开发的中途进行重大的设计变更是可行的。做为对比来看，在实现过程中对实体系统的重大设计进行变更往往更有挑战。例如，在建筑过程中，增加/减少支撑桥梁的支柱的数量是不可行的。

增量式设计意味着软件设计永不结束。设计在系统的生命周期中持续发生:程序员要时刻考虑设计问题。增量开发也意味着持续重构。一个系统的初始设计几乎从来都不是最好的方案。随着经验的增加，必然会发现更好的设计方案。作为程序员，你需要时刻寻找机会来改进当前系统的设计，并且你也需要设计改进做计划，预留时间. [ 遵从 John Ousterhout 老爷子的指导，作为程序员对设计和代码保留着必要的"洁癖",不断追求更好的设计，在面临"将就"和"重构"的时候会做出更好的选择 ]
