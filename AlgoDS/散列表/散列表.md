

# Introduction

散列表是一种用于存储键值对(key-value pair)的数据结构，我们平常经常使用的数组也可以看做是一个特殊的散列表，数组中的“键”即为数组索引，值为相应的数组元素。也就是说，当散列表中所有的键都是较小的整数时，我们可以使用数组来实现散列表，将数组的索引作为键，而索引处的数组元素即为键对应的值，但是这一表示仅限于所有的键都是比较小的整数时，否则可能会使用一个非常大的数组。散列表是对以上策略的一种“升级”，但是它可以支持任意的键而并没有对它们做过多的限定。对于基于散列表实现的散列表，若我们要在其中查找一个键，需要进行以下步骤：

* 首先我们使用**散列函数**将给定键转化为一个“数组的索引”，理想情况下，不同的 key 会被转为不同的索引，但在实际应用中我们会遇到不同的键转为相同的索引的情况，这种情况叫做**碰撞**。解决碰撞的方法我们后面会具体介绍。
* 得到了索引后，我们就可以像访问数组一样，通过这个索引访问到相应的键值对。

以上就是散列表的核心思想，散列表是时空权衡的经典例子。当我们的空间无限大时，我们可以直接使用一个很大的数组来保存键值对，并用 key 作为数组索引，因为空间不受限，所以我们的键的取值可以无穷大，因此查找任何键都只需进行一次普通的数组访问。反过来，若对查找操作没有任何时间限制，我们就可以直接使用链表来保存所有键值对，这样把空间的使用降到了最低，但查找时只能顺序查找。在实际的应用中，我们的时间和空间都是有限的，所以我们必须在两者之间做出权衡，散列表就在时间和空间的使用上找到了一个很好的平衡点。散列表的一个优势在于我们只需调整散列算法的相应参数而无需对其他部分的代码做任何修改就能够在时间和空间的权衡上做出策略调整。散列技术既是一种存储方法，也是一种查找方法。然而它与线性表、 树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向査找的存储结构。

## 散列表的缺陷

### 查找限制

比如那种同样的关键字，它能对应很多记录的情况，却不适合用散列技术。一个班级几十个学生，他们的性别有男有女，你用关键字“男”去査找，对应的有 许多学生的记录，这显然是不合适的。这个时候可以用班级学生的学号或者身份证号来散列存储，此时一个号码唯一对应一个学生才比较合适。同样散列表也不适合范围查找，比如査找一个班级 18-22 岁的同学，在散列表中没法进行。想获得表中记录的排序也不可能，像最大值、最小值等结果也都无法从散列表中计算出来。

### 哈希冲突

另一个问题是冲突。在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。我们时常会碰到两个关键字 key1 ≠ key2，但是却有 f (key1) = f (key2)，这种现象我们称为冲突(collision)，并把 key1 和 key2 称为这个散列函数的同义词(synonym)。出现了冲突当然非常糟糕，那将造成数据査找错误。尽管我们可以通过精心设计的散列函数让冲突尽可能 的少，但是不能完全避免。于是如何处理冲突就成了一个很重要的课题，这在我们后面也需要详细讲解。

## Reference

* [散列表的基本原理与实现](http://www.cnblogs.com/absfree/p/5508570.html)

# 直接定址法

如果我们现在要对 0-100 岁的人口数字统计表，那么我们对年龄这个关键字就可以直接用年龄的数字作为地址。此时 f(key) = key。 ![](http://www.nowamagic.net/librarys/images/201303/2013_03_08_01.png) 如果我们现在要统计的是 80 后出生年份的人口数，那么我们对出生年份这个关键字可以用年份减去 1980 来作为地址。此时 f (key) = key-1980。 ![](http://www.nowamagic.net/librarys/images/201303/2013_03_08_02.png) 也就是说，我们可以取关键字的某个线性函数值为散列地址，即：

```
f(key) = a × key + b
```

# 除留余数法

除留余数法此方法为最常用的构造散列函数方法。对于散列表长为 m 的散列函数公式为：

```
f( key ) = key mod p ( p ≤ m )
```

mod 是取模(求余数)的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。有一个关键字，它有 12 个记录，现在我们要针对它设计一个散列表。如果采用除留余数法，那么可以先尝试将散列函数设计为 f(key) = key mod 12 的方法。比如 29 mod 12 = 5，所以它存储在下标为 5 的位置。 ![](http://www.nowamagic.net/librarys/images/201303/2013_03_13_01.png) 不过这也是存在冲突的可能的，因为 12 = 2×6 = 3×4。如果关键字中有像 18(3×6)、30(5×6)、42(7×6)等数字，它们的余数都为 6，这就和 78 所对应的下标位置冲突了。 ![](http://www.nowamagic.net/librarys/images/201303/2013_03_13_02.png) 但是我们如果不选用 p=12 来做除留余数法，而选用 p=ll，则结果如下： ![](http://www.nowamagic.net/librarys/images/201303/2013_03_13_03.png) 使用除留余数法的一个经验是，若散列表表长为 m，通常 p 为小于或等于表长(最好接近 m)的最小质数或不包含小于 20 质因子的合数。

# 开放定址法

所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。公式为：

```
fi(key) = (f(key)+di) MOD m (di=1,2,3,......,m-1)
```

用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一 个开放的地址(即该地址单元为空)为止(若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元)。查找时探测到开放的地址则表明表中无待查 的关键字，即查找失败。比如说，我们的关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34},表长为 12。 我们用散列函数 f(key) = key mod l2。

当计算前 S 个数{12,67,56,16,25}时，都是没有冲突的散列地址，直接存入：

![img](http://www.nowamagic.net/librarys/images/201303/2013_03_13_04.png)

计算 key = 37 时，发现 f(37) = 1，此时就与 25 所在的位置冲突。

于是我们应用上面的公式 f(37) = (f(37)+1) mod 12 = 2。于是将 37 存入下标为 2 的位置。这其实就是房子被人买了于是买下一间的作法：。

![img](http://www.nowamagic.net/librarys/images/201303/2013_03_13_05.png)

接下来 22,29,15,47 都没有冲突，正常的存入：

![img](http://www.nowamagic.net/librarys/images/201303/2013_03_13_06.png)

到了 key=48，我们计算得到 f(48) = 0，与 12 所在的 0 位置冲突了，不要紧，我们 f(48) = (f(48)+1) mod 12 = 1，此时又与 25 所在的位置冲突。于是 f(48) = (f(48)+2) mod 12=2，还是冲突……一直到 f(48) = (f(48)+6) mod 12 = 6 时，才有空位，机不可失，赶快存入：

![img](http://www.nowamagic.net/librarys/images/201303/2013_03_13_07.png)

我们把这种解决冲突的开放定址法称为[线性探测](http://www.nowamagic.net/academy/tag/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B)法。

从这个例子我们也看到，我们在解决冲突的时候，还会碰到如 48 和 37 这种本来都不是同义词却需要争夺一个地址的情况，我们称这种现象为堆积。很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是査找效率都会大大降低。

## 二次探测法

考虑深一步，如果发生这样的情况，当最后一个 key=34，f(key)=10,与 22 所在的位置冲突，可是 22 后面没有空位置了，反而它的前面有一个空位置，尽管可以 不断地求余数后得到结果，但效率很差。因此我们可以改进 di = 12, -12, 22, -22,……, q2, -q2 (q <= m/2),这样就等于是可以双向寻找到可能的空位置。对于 34 来说，我 们取 di 即可找到空位置了。另外增加平方运算的目的是为了不让关键字都聚集在 某一块区域。我们称这种方法为二次探测法。

```
fi(key) = (f(key)+di) MOD m (di = 12, -12, 22, -22,……, q2, -q2, q <= m/2)
```

## 随机探测法

还有一种方法是，在冲突时，对于位移量 di 采用随机函数计算得到，我们称之为随机探测法。此时一定会有人问，既然是随机，那么查找的时候不也随机生成办吗？如何可以获得相同的地址呢？这是个问题。这里的随机其实是伪随机数。伪随机数是说，如果我们设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，我们在査找时，用同样的随机种子，它每次得到的数列是相同的，相同的 di 当然可以得到相同的散列地址。

```
fi(key) = (f(key)+di) MOD m (di是一个随机数列)
```

总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的办法。

## 链地址法

将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。对于关键字集合{12,67,56,16,25,37, 22,29,15,47,48,34}，我们用前面同样的 12 为除数，进行除留余数法： ![](http://www.nowamagic.net/librarys/images/201303/2013_03_14_01.png) 拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为 m，则可将散列表定义为一个由 m 个头指针组成的指针数组 T[0..m-1]。凡是散列地址为 i 的结点，均插入到以 T[i]为头指针的单链表中。T 中各分量的初值均应为空指针。在拉链法中，装填因子 α 可以大于 1，但一般均取 α≤1。与开放定址法相比，拉链法有如下几个优点：

* 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
* 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
* 开放定址法为减少冲突，要求装填因子 α 较小，故当结点规模较大时会浪费很多空间。而拉链法中可取 α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
* 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被 删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

拉链法的缺点：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。

### C++

```
//#include "stdafx.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"

typedef struct _node
{
    char *name;
    char *desc;
    struct _node *next;
} node;

#define HASHSIZE 101
static node* hashtab[HASHSIZE];

void inithashtab()
{
    int i;
    for(i=0; i < HASHSIZE; i++)
        hashtab[i]=NULL;
}

unsigned int hash(char *s)
{
    unsigned int h=0;
    for(; *s; s++)
        h=*s+h*31;
    return h%HASHSIZE;
}

node* lookup(char *n)
{
    unsigned int hi=hash(n);
    node* np=hashtab[hi];
    for(; np!=NULL; np=np->next)
    {
        if(!strcmp(np->name,n))
            return np;
    }

    return NULL;
}

char* m_strdup(char *o)
{
    int l=strlen(o)+1;
    char *ns=(char*)malloc(l*sizeof(char));
    strcpy(ns,o);
    if(ns==NULL)
        return NULL;
    else
        return ns;
}

char* get(char* name)
{
    node* n=lookup(name);
    if(n==NULL)
        return NULL;
    else
        return n->desc;
}

int install(char* name,char* desc)
{
    unsigned int hi;
    node* np;
    if((np=lookup(name))==NULL)
    {
        hi=hash(name);
        np=(node*)malloc(sizeof(node));
        if(np==NULL)
            return 0;
        np->name=m_strdup(name);
        if(np->name==NULL) return 0;
        np->next=hashtab[hi];
        hashtab[hi]=np;
    }
    else
        free(np->desc);
    np->desc=m_strdup(desc);
    if(np->desc==NULL) return 0;

    return 1;
}

/* A pretty useless but good debugging function,
which simply displays the hashtable in (key.value) pairs
*/
void displaytable()
{
    int i;
    node *t;
    for(i=0; i < HASHSIZE; i++)
    {
        if(hashtab[i]==NULL)
            printf("()");
        else
        {
            t=hashtab[i];
            printf("(");
            for(; t!=NULL; t=t->next)
                printf("(%s.%s) ",t->name,t->desc);
            printf(".)");
        }
    }
}

void cleanup()
{
    int i;
    node *np,*t;
    for(i=0; i < HASHSIZE; i++)
    {
        if(hashtab[i]!=NULL)
        {
            np=hashtab[i];
            while(np!=NULL)
            {
                t=np->next;
                free(np->name);
                free(np->desc);
                free(np);
                np=t;
            }
        }
    }
}

main()
{
    int i;
    char* names[]= {"name","address","phone","k101","k110"};
    char* descs[]= {"Sourav","Sinagor","26300788","Value1","Value2"};

    inithashtab();
    for(i=0; i < 5; i++)
        install(names[i],descs[i]);

    printf("Done");
    printf("If we didnt do anything wrong..""we should see %s\n",get("k110"));

    install("phone","9433120451");

    printf("Again if we go right, we have %s and %s",get("k101"),get("phone"));

    /*displaytable();*/
    cleanup();
    return 0;
}
```
