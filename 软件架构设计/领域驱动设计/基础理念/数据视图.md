# 数据视图

DDD 分层架构中数据对象转换的过程如下图。

![](https://i.postimg.cc/bvY8dgSZ/image.png)

数据视图应用服务通过数据传输对象（DTO）完成外部数据交换。领域层通过领域对象（DO）作为领域实体和值对象的数据和行为载体。基础层利用持久化对象（PO）完成数据库的交换。DTO 与 VO 通过 Restful 协议实现 JSON 格式和对象转换。

前端应用与应用层之间 DTO 与 DO 的转换发生在用户接口层。如微服务内应用服务需调用外部微服务的应用服务，则 DTO 的组装和 DTO 与 DO 的转换发生在应用层。领域层 DO 与 PO 的转换发生在基础层。

# 聚合根（Aggregate Root）

聚合根（Aggregate Root）是 DDD 中的一个概念，是一种更大范围的封装，把一组有相同生命周期、在业务上不可分隔的实体和值对象放在一起考虑，只有根实体可以对外暴露引用，也是一种内聚性的表现。确定聚合边界要满足固定规则（Invariant），是指在数据变化时必须保持的一致性规则，具体规则如下：

- 根实体具有全局标识，最终负责检查规定规则
- 聚合内的实体具有本地标识，这些标识在 Aggregate 内部才是唯一的
- 外部对象不能引用除根 Entity 之外的任何内部对象
- 只有 Aggregate 的根 Entity 才能直接通过数据库查询获取，其他对象必须通过遍历关联来发现
- Aggegate 内部的对象可以保持对其他 Aggregate 根的引用
- Aggregate 边界内的任何对象修改时，整个 Aggregate 的所有固定规则都必须满足

还是看银行的例子，Account（账号）是 CustomerInfo（客户信息）Entity 和 Address（值对象）的聚合根，Tansaction（交易）是流水（Journal）的聚合根，因为流水是因为交易才产生的，具有相同的生命周期。

![](https://i.postimg.cc/qMztqZcL/image.png)

聚合根是一个逻辑概念，主观性很强，所以在建模过程中很容易产生分歧，因此在日常工作中千万不要教条，把握住一条主要原则，我们的最终目的是为了业务语义显现化，如果因为聚合根把模型弄的晦涩难懂那就得不偿失了。

# 边界上下文（Bounded Context）

领域实体是有边界上下文的，比如 Apple 这个实体不同的上下文，表达的含义就完全不一样，在水果店它就是水果，在苹果专卖店它就是手机。

所以边界上下文（Bounded Context）在 DDD 里面是一个非常重要的概念，Bounded Context 明确地限定了模型的应用范围，在 Context 中，要保证模型在逻辑上统一，而不用考虑它是不是适用于边界之外的情况。在其他 Context 中，会使用其他模型，这些模型具有不同的术语、概念、规则和 Ubiquitous Language 的行话。

## 上下文映射（Context Mapping）

不同 Context 下的业务要互相通信就涉及跨边界的 Context Mapping（上下文映射），首先不同上下文之间的通信可以是同步的，也可以是异步的，同步的话一般是 RPC 或者 RESTFul，异步的话会推荐 Domain Event。

Mapping 的方式有很多种，有 Shared Kernal（共享内核），Conformist（追随者），以及 Anti-Corruption（防腐层）等等。比如会员这个概念在 ICBU 网站是指网站上的 Buyer，但是在 CRM 领域是指 Customer，虽然很多的属性都是一样的，但是二者在不同的 Context 下其语义和概念是有差别的，我们需要用 AC 做一下转换：

![](https://i.postimg.cc/fWKzs76v/image.png)

# 领域状态

在软件设计领域经常会提到状态（State）这个词，而服务之间的状态本质上体现的还是一种数据关系。如果一个数据需要在多个服务之间共享才能完成一项业务功能，那么这项业务功能就被称为有状态。基于这项业务功能所设计和实现的一系列服务之间就形成了一种状态性，这一系列服务就是有状态服务。

很多服务都会把自己的状态下沉到一个庞大的共享数据库中，这也是一些传统 Web 框架的做法。这种做法就会造成在扩展性、可用性以及数据集成上很难做好把控。而在本质上，一个使用共享数据库的微服务架构本质还是一个单体应用。一个服务既然具有单一职责，那么合理的方式就应该是该服务拥有自己的状态和持久化机制，建模成一个边界上下文。这里就需要充分应用领域驱动设计（Domain Driven Design，DDD）中的相关策略设计和技术设计方面的方法和工程实践。
