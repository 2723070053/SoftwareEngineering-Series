# CQRS

CQRS(Command Query Separation，命令查询分离)最早来自于 Betrand Meyer（Eiffel 语言之父，OCP 提出者）提出的概念。其基本思想在于任何一个对象的方法可以分为两大类：

- 命令(Command)：不返回任何结果(void)，但会改变对象的状态。
- 查询(Query)：返回结果，但是不会改变对象的状态，对系统没有副作用。

CQRS 使用分离的接口将数据查询操作（Queries）和数据修改操作（Commands）分离开来，这也意味着在查询和更新过程中使用的数据模型也是不一样的。这样读和写逻辑就隔离开来了，分离了读写职责之后，可以对数据进行读写分离操作来改进性能，可扩展性和安全性。

![](https://i.postimg.cc/kXcKDsx2/image.png)

# 设计理念

## 读写分离

主数据库处理 CUD，从库处理 R，从库的的结构可以和主库的结构完全一样，也可以不一样，从库主要用来进行只读的查询操作。在数量上从库的个数也可以根据查询的规模进行扩展，在业务逻辑上，也可以根据专题从主库中划分出不同的从库。从库也可以实现成 ReportingDatabase，根据查询的业务需求，从主库中抽取一些必要的数据生成一系列查询报表来存储。

![](https://i.postimg.cc/L4v81bbF/image.png)

在 CQRS 中，所有的涉及到对 DB 的操作都是通过发送 Command，然后特定的 Command 触发对应事件来完成操作，这个过程是异步的，并且所有涉及到对系统的变更行为都包含在具体的事件中，结合 Eventing Source 模式，可以记录下所有的事件，而不是以往的某一点的数据信息，这些信息可以作为系统的操作日志，可以来对系统进行回退或者重放。

## 事务脚本与 DDD

CQRS 就是对事务脚本和领域模型两种模式的综合，因为对于 Query 和报表的场景，使用领域模型往往会把简单的事情弄复杂，此时完全可以用奥卡姆剃刀把领域层剃掉，直接访问 Infrastructure。

CQRS 还可以与 DDD 相结合：

![](https://i.postimg.cc/YCQc14CL/image.png)

# 优势与对比

- 分工明确，可以负责不同的部分

- 将业务上的命令和查询的职责分离能够提高系统的性能、可扩展性和安全性。并且在系统的演化中能够保持高度的灵活性，能够防止出现 CRUD 模式中，对查询或者修改中的某一方进行改动，导致另一方出现问题的情况。

- 逻辑清晰，能够看到系统中的那些行为或者操作导致了系统的状态变化。

- 可以从数据驱动(Data-Driven) 转到任务驱动(Task-Driven)以及事件驱动(Event-Driven)。

## 数据一致性

传统架构，数据一般是强一致性的，通常会使用数据库事务保证一次操作的所有数据修改都在一个数据库事务里，从而保证了数据的强一致性。在分布式的场景，同样希望数据的强一致性，就是使用分布式事务。但是众所周知，分布式事务的难度、成本是非常高的，而且采用分布式事务的系统的吞吐量都会比较低，系统的可用性也会比较低。所以，很多时候，也会放弃数据的强一致性，而采用最终一致性；从 CAP 定理的角度来说，就是放弃一致性，选择可用性。

CQRS 架构，则完全秉持最终一致性的理念。这种架构基于一个很重要的假设，就是用户看到的数据总是旧的。对于一个多用户操作的系统，这种现象很普遍。比如秒杀的场景，当你下单前，也许界面上你看到的商品数量是有的，但是当你下单的时候，系统提示商品卖完了。在界面上看到的数据是从数据库取出来的，一旦显示到界面上，就不会变了。但是很可能其他人已经修改了数据库中的数据。这种现象在大部分系统中，尤其是高并发的 WEB 系统，尤其常见。

所以，基于这样的假设，即便系统做到了数据的强一致性，用户还是很可能会看到旧的数据。所以，这就给设计架构提供了一个新的思路。能否这样做：只需要确保系统的一切添加、删除、修改操作所基于的数据是最新的，而查询的数据不必是最新的。这样就很自然的引出了 CQRS 架构了。C 端数据保持最新、做到数据强一致；Q 端数据不必最新，通过 C 端的事件异步更新即可。所以，基于这个思路开始思考，如何具体的去实现 CQ 两端。

## 扩展性

传统架构，各个组件之间是强依赖，都是对象之间直接方法调用；CQRS 架构，则是事件驱动的思想；从微观的聚合根层面，传统架构是应用层通过过程式的代码协调多个聚合根一次性以事务的方式完成整个业务操作,而 CQRS 架构，则是通过事件驱动的方式，最终实现多个聚合根的交互，CQ 两端也是通过事件的方式异步进行数据同步，也是事件驱动的一种体现。

架构层面，传统架构是 SOA 的思想，CQRS 是 EDA 的思想。SOA 是一个服务调用另一个服务完成服务之间的交互，服务之间紧耦合；EDA 是一个组件订阅另一个组件的事件消息，根据事件信息更新组件自己的状态，所以 EDA 架构，每个组件都不会依赖其他的组件；组件之间仅仅通过 topic 产生关联，耦合性非常低。例如原来 A 服务调用了 B,C 两个服务，后来想多调用一个服务 D，SOA 则需要改 A 服务的逻辑；而 EDA 架构，不需要动现有的代码，原来有 B,C 两订阅者订阅 A 产生的消息，现在只需要增加一个新的消息订阅者 D 即可。

## 可用性

统架构和 CQRS 架构，都可以做到高可用，只要做到让系统中每个节点都无单点即可。但是，相比之下 CQRS 架构可以有更多的回避余地和选择空间。传统架构，可用性要把读写合在一起综合考虑。CQRS 架构把读和写分离了，可用性相当于被隔离在了两个部分去考虑。

C 端可用性更加容易的，因为 C 端是消息驱动的。做任何数据修改时，都会发送 Command 到分布式消息队列，然后后端消费者处理 Command->产生领域事件->持久化事件->发布事件到分布式消息队列->最后事件被 Q 端消费。这个链路是消息驱动的。相比传统架构的直接服务方法调用，可用性要高很多。因为就算处理 Command 的后端消费者暂时挂了，也不会影响前端 Controller 发送 Command，Controller 依然可用。

Q 端和传统架构没什么区别，因为都是要处理高并发的查询。以前怎么优化的，现在还是怎么优化。

# 使用场景

- 当在业务逻辑层有很多操作需要相同的实体或者对象进行操作的时候。CQRS 使得我们可以对读和写定义不同的实体和方法，从而可以减少或者避免对某一方面的更改造成冲突

- 对于一些基于任务的用户交互系统，通常这类系统会引导用户通过一系列复杂的步骤和操作，通常会需要一些复杂的领域模型，并且整个团队已经熟悉领域驱动设计技术。写模型有很多和业务逻辑相关的命令操作的堆，输入验证，业务逻辑验证来保证数据的一致性。读模型没有业务逻辑以及验证堆，仅仅是返回 DTO 对象为视图模型提供数据。读模型最终和写模型相一致。

- 适用于一些需要对查询性能和写入性能分开进行优化的系统，尤其是读/写比非常高的系统，横向扩展是必须的。比如，在很多系统中读操作的请求时远大于写操作。为适应这种场景，可以考虑将写模型抽离出来单独扩展，而将写模型运行在一个或者少数几个实例上。少量的写模型实例能够减少合并冲突发生的情况

- 适用于一些团队中，一些有经验的开发者可以关注复杂的领域模型，这些用到写操作，而另一些经验较少的开发者可以关注用户界面上的读模型。

- 对于系统在将来会随着时间不段演化，有可能会包含不同版本的模型，或者业务规则经常变化的系统

- 需要和其他系统整合，特别是需要和事件溯源 Event Sourcing 进行整合的系统，这样子系统的临时异常不会影响整个系统的其他部分。
