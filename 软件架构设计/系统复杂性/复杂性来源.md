# 复杂性的来源

# 吸积与持续迭代

从字面上我们可以理解为吸附和积累。每次加一点，每次加一点，最后就有了一大堆。这句话来描述吸积效应最好不过，出自 1975 年出版的《人月神话》。无论一次代码迭代和升级看上去是多么独立，客观上导致的结果就是代码量从一点点变成一大堆，遗留代码和遗留系统就是这样形成的。遗留代码到底有什么问题？吸积效应导致代码十分庞大，没有人可以完全了解这个系统。当系统出现问题时，最了解这部分代码的人可能已经离职而杳无音讯。

软件本身如此易变(malleable),因此软件设计是持续的过程，贯穿软件系统的整个生命周期。软件设计的这个特点，使它和现实世界中实体系统(例如建筑，船舶，桥梁)的设计差异很大。然而，人们并不是从一开始就认可软件设计设计的持续性特点。在软件开发历史上很大一部分时间里，设计被认为和其他的工程一样：设计过程集中在项目的开始阶段.这种方式的一个极端就是瀑布式开发模型。在这个模型中，项目被划分为分离(discrete)的各个阶段:需求分析，设计，编码，测试和维护，前一个阶段在下一个阶段开始前结束，并且很多场景下，不同人负责不同的阶段。整个系统的设计工作在设计阶段一次性完成，这个阶段结束后，设计就冻结了。后面的各个阶段就是逐步实现设计的过程.

不幸的是，瀑布流开发模型很少在软件开发中有效。软件系统比其他实体系统内在(intrinsically)复杂性更高.大型软件系统，很难在开发前设想清楚系统设计个各个方面和准确理解各个设计决策的影响。结果是，初始的设计会有很多问题，这些问题一开始并不明显，在实现的过程中才变得更加清晰。瀑布开发模型没有组织上的保障来适应这种设计变化(例如:软件设计人员可能已经调整到其他项目上). 因此，开发人员尝试在不修改整体设计的前提下，通过补丁(patch)的方式来修复问题.这导致复杂性的爆炸性增长.

因为有这些问题，今天大部分软件开发项目采用了增量式开发模式(例如敏捷开发模式).在这种模式下，初始的设计聚焦在整体功能的一小部分上进行设计，实现和评估。初始设计的问题逐步被发现，并被纠正。随后更多的功能点被设计，实现和评估。每个迭代都暴露已有设计的问题，这些问题在下一个功能集的设计前得到解决。通过将设计的分散(spread out)，初始设计的问题能够在系统还很小的阶段得到修复。得益于初始阶段获得的经验，后续功能设计问题会更少.

这种增量式开发模型之所以有效，是因为软件系统具有足够的可塑性(malleable)，使得在软件开发的中途进行重大的设计变更是可行的。做为对比来看，在实现过程中对实体系统的重大设计进行变更往往更有挑战。例如，在建筑过程中，增加/减少支撑桥梁的支柱的数量是不可行的。

增量式设计意味着软件设计永不结束。设计在系统的生命周期中持续发生:程序员要时刻考虑设计问题。增量开发也意味着持续重构。一个系统的初始设计几乎从来都不是最好的方案。随着经验的增加，必然会发现更好的设计方案。作为程序员，你需要时刻寻找机会来改进当前系统的设计，并且你也需要设计改进做计划，预留时间. [ 遵从 John Ousterhout 老爷子的指导，作为程序员对设计和代码保留着必要的"洁癖",不断追求更好的设计，在面临"将就"和"重构"的时候会做出更好的选择 ]

# 交互且无扩展性设计

当吸积效应导致的大规模系统，结合了交互这个特性，会使技术系统更加复杂。一个技术系统除了作用于自身，还会与其它大量系统产生交互。比如下单购买一件商品，那么订单系统，商品系统，支付系统，物流系统，卡券系统就会交互协作。这样吸积的复杂性，由于交互特性的出现，会呈现几何级数上升。交互带来两种特性：第一是互操作性。在搜索引擎上查询去某地怎么走，搜索引擎会告诉你打车需要多长时间，并提供一个打车按钮。第二是相互依赖性。比如下订单时需要使用优惠券，那么当卡券系统出现问题时就会影响订单系统。

对于只有一个业务的简单场景，并不需要扩展，问题也不突出，这也是为什么这个点经常被忽略的原因，因为我们大部分的系统都是从单一业务开始的。但是随着支持的业务越来越多，代码里面开始出现大量的 if-else 逻辑，这个时候代码开始有坏味道，没闻到的同学就这么继续往上堆，闻到的同学会重构一下，但因为系统没有统一的可扩展架构，重构的技法也各不相同，这种代码的不一致性也是一种理解上的复杂度。久而久之，系统就变得复杂难维护。像我们 CRM 应用，有 N 个业务方，每个业务方又有 N 个租户，如果都要用 if-else 判断业务差异，那简直就是惨绝人寰。其实这种扩展点（Extension Point），或者叫插件（Plug-in）的设计在架构设计中是非常普遍的。比较成功的案例有 eclipse 的 plug-in 机制，集团的 TMF2.0 架构。还有一个扩展性需求就是字段扩展，这一点对 SaaS 应用尤为重要，因为有很多客户定制化需求，但是我们很多系统也没有统一的字段扩展方案。

# 面向过程而不是对象

是的，不管你承认与否，很多时候，我们都是操着面向对象的语言干着面向过程的勾当。面向对象不仅是一个语言，更是一种思维方式。在我们追逐云计算、深度学习、区块链这些技术热点的时候，静下心来问问自己我们是不是真的掌握了 OOD；在我们强调工程师要具备业务 Sense，产品 Sense，数据 Sense，算法 Sense，XXSense 的时候，是不是忽略了对工程能力的要求。据我观察大部分工程师（包括我自己）的 OO 能力还远没有达到精通的程度，这种 OO 思想的缺乏主要体现在两个方面，一个是很多同学不了解 SOLID 原则，不懂设计模式，不会画 UML 图，或者只是知道，但从来不会运用到实践中；另一个是不会进行领域建模，关于领域建模争论已经很多了，我的观点是 DDD 很好，但不是银弹，用和不用取决于场景。但不管怎样，请你抛开偏见，好好的研读一下 Eric Evans 的《领域驱动设计》，如果有认知升级的感悟，恭喜你，你进阶了。我个人认为 DDD 最大的好处是将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）将领域概念清晰的显性化表达出来。相信我，这种表达带来的代码可读性的提升，会让接手你代码的人对你心怀感恩的。

# 分层不合理

俗话说的好，All problems in computer science can be solved by another level of indirection（计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决），怎样？ 是不是感受到间接层的强大了。分层最大的好处就是分离关注点，让每一层只解决该层关注的问题，从而将复杂的问题简化，起到分而治之的作用。我们平时看到的 MVC，pipeline，以及各种 valve 的模式，都是这个道理。好吧，那是不是层次越多越好，越灵活呢。当然不是，就像我开篇说的，过多的层次不仅不能带来好处，反而会增加系统的复杂性和降低系统性能。就拿 ISO 的网络七层协议来说，你这个七层分的很清楚，很好，但也很繁琐，四层就够了嘛。再比如我前面提到的过度设计的例子，如果没记错的话应该是 Apple 的 Directory Service 应用，整个系统有 7 层之多，把什么 validator，assembler 都当成一个层次来对待，能不复杂么。所以分层太多和没有分层都会导致系统复杂度的上升，因此我们的原则是不可以没有分层，但是只分有必要的层。

# 缺乏约束与规范

随心所欲是因为缺少规范和约束。这个规范非常非常非常的重要（重要事情说三遍），但也是最容易被无视的点，其结果就是架构的 consistency 被严重破坏，代码的可维护性将急剧下降，国将不国，架构将形同虚设。有同学会说不就是个 naming 的问题么，不就是个分包的问题么，不就是 2 个 module 还是 3 个 module 的问题么，只要功能能跑起来，这些问题都是小问题。是的，对于这些同学，我再丢给你一句名言“Just because you can, doesn't mean you should"。就拿 package 来说，它不仅仅是一个放一堆类的地方，更是一种表达机制，当你将一些类放到 Package 中时，相当于告诉下一位看到你设计的开发人员要把这些类放在一起考虑。理想很丰满，现实很骨感，规范的执行是个大问题，最好能在架构层面进行约束，例如在我们架构中，扩展点必须以 ExtPt 结尾，扩展实现必须以 Ext 结尾，你不这么写就会给你抛异常。但是架构的约束毕竟有限，更多的还是要靠 Code Review，暂时没想到什么更好的办法。这种对架构约束的近似严苛 follow，确保了系统的 consistency，最终形成了一个规整的收纳箱（如下图所示），就像我和团队说的，我们在评估代码改动点时，应该可以像 Hash 查找一样，直接定位到对应的 module，对应的 package 里面对应的 class。而不是到“一锅粥”里去慢慢抠。
