# 复杂性应对

本节将讨论控制系统复杂性的两个通用途径。第一个控制复杂性的途径是代码简单，意图清晰(obvious)。例如: 减少特殊场景的处理，或变量命名一致性都能降低系统复杂性。

第二个途径是复杂性封装(encapsulate),这样程序员可以不用一次面对系统全部的复杂性，这个也被称为模块设计。在模块设计，系统被划分为各个模块，例如面向对象设计语言中的类。这些模块被设计为彼此间相对独立，程序员在开发一个模块的时候，不需要考虑其他模块的实现细节。

# 简单设计

# 复杂性封装

# 扩展点设计

## 身份识别

业务身份识别在我们的应用中非常重要，因为我们的 CRM 系统要服务不同的业务方，而且每个业务方又有多个租户。比如中供销售，中供拍档，中供商家都是不同的业务方，而拍档下的每个公司，中供商家下的每个供应商又是不同的租户。所以传统的基于多租户（TenantId）的业务身份识别还不能满足我们的要求，于是在此基础上我们又引入了业务码（BizCode）来标识业务。所以我们的业务身份实际上是（BizCode，TenantId）二元组。在每一个业务身份下面，又可以有多个扩展点（ExtensionPoint），所以一个扩展点实现（Extension）实际上是一个三维空间中的向量。我给它起了个名字叫扩展坐标，这个坐标可以用（ExtensionPoint，BizCode，TenantId）来唯一标识。

![](https://i.postimg.cc/gkSbz9Br/image.png)

## 扩展点机制

扩展点的设计是这样的，所有的扩展点（ExtensionPoint）必须通过接口申明，扩展实现（Extension）是通过 Annotation 的方式标注的，Extension 里面使用 BizCode 和 TenantId 两个属性用来标识身份，框架的 Bootstrap 类会在 Spring 启动的时候做类扫描，进行 Extension 注册，在 Runtime 的时候，通过 TenantContext 来选择要使用的 Extension。TenantContext 是通过 Interceptor 在调用业务逻辑之前进行初始化的。整个过程如下图所示：

![](https://i.postimg.cc/mDfGvQpw/image.png)
